#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     IRSensor,       sensorI2CCustom)
#pragma config(Sensor, S4,     sonarSensor,    sensorSONAR)
#pragma config(Motor,  mtr_S1_C1_1,     motorHang,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorArm,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     motorLeft,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorRight,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_1,     motorFlag,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C2_1,    servoScoop,           tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    servoIRDrop,          tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
//constants for direction of the drive
/////////////////////////////////////////////////////////////////////////////////////////////////////
const int FORWARD = 2;
const int BACKWARD = 1;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//constants needed to caluclate distance
/////////////////////////////////////////////////////////////////////////////////////////////////////
const int ONE_REVOLUTION  = 1440; 	// one revolution = 1440 Ticks
const int WHEEL_DIAMETER = 4;  			// current wheel diameter = 4 inches
const float PI = 3.14159265359;

//should find the fourth basket within 45 inches from the start position
const int BASKET_ZONE4_MAX  = (ONE_REVOLUTION/(PI * WHEEL_DIAMETER)) * 50 ;
const int BASKET_ZONE3_MAX = (ONE_REVOLUTION/(PI * WHEEL_DIAMETER)) * 45;

#include "JoystickDriver.c"  							//Include file to "handle" the Bluetooth messages.
#include "Drivers/Common.h"
#include "Drivers/hitechnic-colour-v2.h"
#include "Drivers/hitechnic-irseeker-v2.h"
#include "JDroidsHelperFunctions.c"				//Include file to "handle" JDroids functions.


//////////////////////////////////////////////////////////////////////////////////////
// SwingTurnLeft
// Turn towards Basket
// called from DropBlock function
//////////////////////////////////////////////////////////////////////////////////////
void SwingTurnLeft()
{
	  //initialize the encoders
		nMotorEncoder[motorRight] = 0;
		nMotorEncoder[motorLeft] = 0;

		//set the encoder to predefined value
		nMotorEncoderTarget[motorRight] = 1900;
		nMotorEncoderTarget[motorLeft] = 1900;

		//power the motors
		motor[motorRight] = 40;
		motor[motorLeft] = -40;

		//wait for the motor to become idle
		while(nMotorRunState[motorRight] != runStateIdle || nMotorRunState[motorLeft] != runStateIdle)
		{
		}

		//stop the motors
		motor[motorRight] = 0;
		motor[motorLeft] = 0;
}


//////////////////////////////////////////////////////////////////////////////////////
// SwingTurnRight
// Turnback to go back where the robot started
//////////////////////////////////////////////////////////////////////////////////////
void SwingTurnRight()
{
		//initialize the encoders
		nMotorEncoder[motorRight] = 0;
		nMotorEncoder[motorLeft] = 0;

		//set the encoder to predefined value
		nMotorEncoderTarget[motorRight] = 2000;
		nMotorEncoderTarget[motorLeft] = 2000;

		//power the motors
		motor[motorRight] = -45;
		motor[motorLeft] = 45;

		//wait for the motor to become idle
		while(nMotorRunState[motorRight] != runStateIdle || nMotorRunState[motorLeft] != runStateIdle)
		{
			//continue back to the while if  target is not reached
		}

		//stop the motors
		motor[motorRight] = 0;
		motor[motorLeft] = 0;
}


//////////////////////////////////////////////////////////////////////////////////////
// SwingTurnRight2
// Turn towards the ramp
// Parmeter - ThirdOrFourthBasket, if 1 needs to turn less else turn more
//////////////////////////////////////////////////////////////////////////////////////
void SwingTurnRight2(int ThirdOrFourthBasket)
{
		//initialize the values
		nMotorEncoder[motorRight] = 0;
		nMotorEncoder[motorLeft] = 0;

		//check to see if the drop was done on the first,second or third/four and turn
		if ( ThirdOrFourthBasket == 1 )
		{
			nMotorEncoderTarget[motorRight] = 1200;
			nMotorEncoderTarget[motorLeft] = 1200;
		}
		else
		{
			nMotorEncoderTarget[motorRight] = 2200;
			nMotorEncoderTarget[motorLeft] = 2200;
		}

		//power the motors
		motor[motorRight] = -45;
		motor[motorLeft] = 45;

		//wait to complete
		while(nMotorRunState[motorRight] != runStateIdle || nMotorRunState[motorLeft] != runStateIdle)
		{
		}

		//stop the motors
		motor[motorRight] = 0;
		motor[motorLeft] = 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
//
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving.
//
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void initializeRobot()
{
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

	//IR Mode set
  tHTIRS2DSPMode _mode = DSP_1200;
	HTIRS2setDSPMode(IRSensor, _mode);

	//scoop all the way up to hold the autonomous block
	servo[servoScoop] = 0;
	servo[servoIRDrop]=240;
	return;

}

void DropBlockIR()
{
	servo[servoIRDrop]=120;
	wait10Msec(70);
}


void MoveUntilIRNoEncoder()
{
	 motor[motorRight]=20;
	 motor[motorLeft]=20;
	 int direction = HTIRS2readACDir(IRSensor);

	 while(  direction != 5  )  {
		// read the direction
		direction = HTIRS2readACDir(IRSensor);

	}

  motor[motorRight]=0;
	motor[motorLeft]=0;
}



/////////////////////////////////////////////////////////////////////////////////////////////////////
// Task - RaiseRack
// This thread raises the rack and allows the robot to drive freely
/////////////////////////////////////////////////////////////////////////////////////////////////////
void RaiseRack()
{

   //power the motor to raise the rack up
		motor[motorHang] = 50;
    wait10Msec(15);
		//stop the motor
		motor[motorHang] = 0;
}

//////////////////////////////////////////////////////////////////////////////////////
// SwingTurnLeftRamp
//////////////////////////////////////////////////////////////////////////////////////
void SwingTurnRightRamp()
{
		nMotorEncoder[motorRight] = 0;
		nMotorEncoder[motorLeft] = 0;

		nMotorEncoderTarget[motorRight] = 1200;
		nMotorEncoderTarget[motorLeft] = 1200;

		motor[motorRight] = -50;
		motor[motorLeft] = 50;

		while(nMotorRunState[motorRight] != runStateIdle || nMotorRunState[motorLeft] != runStateIdle)
		{
		}

		motor[motorRight] = 0;
		motor[motorLeft] = 0;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation.
//
// Sequence of Operations:
//
// 1. Detect the IR beam
// 2. Turn and Drop the block
// 3. Find the Blue or Red Line
// 4. Climb the Ramp
//
// At the end of the autonomous period, the FMS will autonmatically abort execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
task main()
{

	//initialize the servos
  initializeRobot();

  bFloatDuringInactiveMotorPWM = true;

	// Wait for the beginning of autonomous phase.
  waitForStart();

	//raise the rack so that the robot can move easily
  RaiseRack();

  //move the arm up so that the robot can move easily
  motor[motorArm] = 65;
  wait1Msec(1000);
  motor[motorArm] = 0;


 	//detect the IR beam, we get out when 5 is detected
 	MoveUntilIRNoEncoder();
  wait10Msec(15);

  //Drop the block in the basket
  DropBlockIR();

  //Bring the drop block mechanism higher
  servo[servoIRDrop] = 255 ;


  //Move backwards after IR drop.
  motor[motorLeft]= -50;
  motor[motorRight] = -50;
  wait10Msec(100);
  motor[motorLeft]= 0;
  motor[motorRight] = 0;

  while(true)
  {

  }

  //back away from the basket
  Move(2, BACKWARD, 30);

	//turn back
  SwingTurnRight();


  //stop the motors
  motor[motorLeft] = 0;
  motor[motorRight] = 0;
  wait10Msec(3);


	//check for other robots
	if(SensorValue[sonarSensor] <= 75) //if obstruction is present, max power
		Move(13.5, BACKWARD, 100);
	else if(SensorValue[sonarSensor] > 75)
		Move(10, BACKWARD, 60);

	// We are done
  while (true)
	{

	}

}
