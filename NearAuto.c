#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     IRSensor,       sensorI2CCustom)
#pragma config(Sensor, S4,     sonarSensor,    sensorSONAR)
#pragma config(Motor,  mtr_S1_C1_1,     motorHang,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorArm,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     motorLeft,     tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     motorRight,    tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     motorFlag,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C2_1,    servoScoop,           tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    servoIRDrop,          tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
/////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
//constants for direction of the drive
/////////////////////////////////////////////////////////////////////////////////////////////////////
const int FORWARD = 2;
const int BACKWARD = 1;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//constants needed to caluclate distance
/////////////////////////////////////////////////////////////////////////////////////////////////////
const int ONE_REVOLUTION  = 1440; 	// one revolution = 1440 Ticks
const int WHEEL_DIAMETER = 4;  			// current wheel diameter = 4 inches
const float PI = 3.14159265359;

//should find the fourth basket within 45 inches from the start position
const int BASKET_ZONE4_MAX  = (ONE_REVOLUTION/(PI * WHEEL_DIAMETER)) * 62 ;

#include "JoystickDriver.c"  							//Include file to "handle" the Bluetooth messages.
#include "Drivers/Common.h"
#include "Drivers/hitechnic-colour-v2.h"
#include "Drivers/hitechnic-irseeker-v2.h"
#include "JDroidsHelperFunctions.c"				//Include file to "handle" JDroids functions.


////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
//
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving.
//
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void initializeRobot()
{
  //Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.
	//IR Mode set
  tHTIRS2DSPMode _mode = DSP_1200;
	HTIRS2setDSPMode(IRSensor, _mode);

	//scoop all the way up to hold the autonomous block
	servo[servoScoop] = 185;
	servo[servoIRDrop]= 28;
	nMotorEncoder[motorRight] = 0;
	nMotorEncoder[motorLeft] = 0;
	wait1Msec(30);
	return;
}


//////////////////////////////////////////////////////////////////////////////////////
// PointTurnRight
// Turnback to go back where the robot started
//////////////////////////////////////////////////////////////////////////////////////
void PointTurnRight(int Seconds)
{
		motor[motorRight] = -55;
		motor[motorLeft] = 55;
		wait1Msec(Seconds);
		motor[motorRight] = 0;
		motor[motorLeft] = 0;
}

void DropBlockIR()
{
	servo[servoIRDrop]=10;
	wait1Msec(700);
}

//////////////////////////////////////////////////////////////////////////////////////
//
// IR Functions
//
//////////////////////////////////////////////////////////////////////////////////////
int  MoveUntilIR()
{
	//1. Reset the encoders
	nMotorEncoder[motorLeft] = 0;
	nMotorEncoder[motorRight] = 0;
	wait1Msec(30);

	//2. Start the motors, different speeds as motor has a bias
	motor[motorLeft] = 35;
	motor[motorRight] = 35;


	//3. Set the variables to track the numbe of revolutions, so robot knows its position on the field
	int currentTicks = 0;
	string sTemp;

	// 4. Detect the IR beam
	// Read direction from the IR in a while loop
	// While loop exits, if either 5 is detected or if robot is past the 4th basket

	int direction = HTIRS2readACDir(IRSensor);
	while(  direction != 5  )  {
		// read the direction
		direction = HTIRS2readACDir(IRSensor);

		// read the number of ticks - that is how far the robot has moved since it started
		currentTicks = nMotorEncoder[motorRight];

		// check to see if we are past the 4th basket
		if (currentTicks >= BASKET_ZONE4_MAX )
		{
	  	//IR Seeker did not detect the IR beam, we are way past the 4th basket,
	    //need to stop moving
	    break;
		}
		//sprintf(sTemp, "%d", currentTicks);
		//nxtDisplayString(2, sTemp);
	}
	//5. Stop moving
	motor[motorRight] = 0;
	motor[motorLeft] = 0;


	//6. Return Ticks Moved
	return currentTicks;

}


/////////////////////////////////////////////////////////////////////////////////////////////////////
// Task - RaiseRack
// This thread raises the rack and allows the robot to drive freely
/////////////////////////////////////////////////////////////////////////////////////////////////////
void RaiseRack()
{
	 //power the motor to raise the rack up
		motor[motorHang] = 50;
    wait10Msec(15);
		//stop the motor
		motor[motorHang] = 0;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                         Main Task
// The following is the main code for the autonomous robot operation.
// Sequence of Operations:
// 1. Detect the IR beam
// 2. Drop the block
// 3. Backup, Turn, Go Back, Turn
// 4. Climb the Ramp
// At the end of the autonomous period, the FMS will autonmatically abort execution of the program.
/////////////////////////////////////////////////////////////////////////////////////////////////////
task main()
{


	//initialize the servos
  initializeRobot();


  bFloatDuringInactiveMotorPWM = true;

	// Wait for the beginning of autonomous phase.
  waitForStart();


	//raise the rack so that the robot can move easily
  RaiseRack();

  //move the arm up so that the robot can move easily
  motor[motorArm] = 65;
  wait1Msec(300);
  motor[motorArm] = 0;

 	//detect the IR beam, we get out when 5 is detected
 	//returns the number of ticks moved
 	int currentTicks = MoveUntilIR();

 	//move up a small amount
 	Move(8, FORWARD, 35);
	wait1Msec(30);

	//drop the block
 	DropBlockIR();

  //Bring the drop block mechanism higher,
 	//so that its not in the way of the center part of the beam
  servo[servoIRDrop] = 28 ;
	wait1Msec(70);

	//backup
  //dont go to the start position, start a bit before, so that wall will not be touched
  nMotorEncoder[motorRight] = 0;
  nMotorEncoder[motorLeft] = 0;
  wait1Msec(30);

  nMotorEncoderTarget[motorRight] =  (currentTicks * -1)  + 600;
	nMotorEncoderTarget[motorLeft] =  (currentTicks * -1)  + 600;
  //power  the right motor earlier than the left motor
  motor[motorRight] = -35;
  motor[motorLeft] = -35;

  //wait for it go back
  while ( nMotorRunState[motorRight] != runStateIdle || nMotorRunState[motorLeft] != runStateIdle  )
  {
  }

  //stop the motors
  motor[motorLeft] = 0;
  motor[motorRight] = 0;
	wait1Msec(50);

	//turnright towards the ramp
	PointTurnRight(1100);
	wait1Msec(30);

	//go back a bit for more clearance
	Move(43, BACKWARD, 55);
	wait1Msec(30);

	PointTurnRight(1300);
	wait1Msec(30);

	Move(28, BACKWARD, 55);
	wait1Msec(30);

	//brake instead of coast
	bFloatDuringInactiveMotorPWM = false;

	//check for other robots
	if(SensorValue[sonarSensor] <= 75) //if obstruction is present, max power
		Move(13, BACKWARD, 90);
	else if(SensorValue[sonarSensor] > 75)
		Move(13, BACKWARD, 60);


	// We are done
  while (true)
	{
	}

}
