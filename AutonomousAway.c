#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  HTMotor)
#pragma config(Sensor, S3,     IRSensor,       sensorI2CCustom)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     motorHang,     tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorArm,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     motorLeft,     tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     motorRight,    tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     motorFlag,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
//constants for direction of the drive
/////////////////////////////////////////////////////////////////////////////////////////////////////
const int FORWARD = 1;
const int BACKWARD = 2;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//constants needed to caluclate distance
/////////////////////////////////////////////////////////////////////////////////////////////////////
const int ONE_REVOLUTION  = 1440; 	// one revolution = 1440 Ticks
const int WHEEL_DIAMETER = 4;  			// current wheel diameter = 4 inches
const float PI = 3.14159265359;

//should find the fourth basket within 45 inches from the start position
const int BASKET_ZONE4_MAX  = (ONE_REVOLUTION/(PI * WHEEL_DIAMETER)) * 45 ;


#include "JoystickDriver.c"  							//Include file to "handle" the Bluetooth messages.
#include "Drivers/Common.h"
#include "Drivers/hitechnic-colour-v2.h"
#include "Drivers/hitechnic-irseeker-v2.h"
#include "JDroidsHelperFunctions.c"				//Include file to "handle" Move/IR common functions for autonomous run.

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// TurnLeft
//      Function used to turn with the back wheel facing the ramp after sensing the blue/red color
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void TurnLeft()
{
		nMotorEncoder[motorRight] = 0;
		nMotorEncoder[motorLeft] = 0;

		nMotorEncoderTarget[motorRight] = 3400;
		nMotorEncoderTarget[motorLeft] = 0;

		motor[motorRight] = -60;
		motor[motorLeft] = 0;

		while(nMotorRunState[motorRight] != runStateIdle)
		{
		}

		motor[motorRight] = 0;
		motor[motorLeft] = 0;
}



//////////////////////////////////////////////////////////////////////////////////////
//
// SwingTurnLeft
// 		Function used to turn towards the basket after detection IR beam
//
//////////////////////////////////////////////////////////////////////////////////////
void SwingTurnLeft()
{
		nMotorEncoder[motorRight] = 0;
		nMotorEncoder[motorLeft] = 0;

		nMotorEncoderTarget[motorRight] = 2800;
		nMotorEncoderTarget[motorLeft] = 2800;

		motor[motorRight] = 30;
		motor[motorLeft] = -30;

		while(nMotorRunState[motorRight] != runStateIdle || nMotorRunState[motorLeft] != runStateIdle)
		{
		}

		motor[motorRight] = 0;
		motor[motorLeft] = 0;
}


//////////////////////////////////////////////////////////////////////////////////////
//
// SwingTurnRight
//		Function used to turn near the basket to get back to the ramp
//
//////////////////////////////////////////////////////////////////////////////////////
void SwingTurnRight()
{
		nMotorEncoder[motorRight] = 0;
		nMotorEncoder[motorLeft] = 0;

		nMotorEncoderTarget[motorRight] = 1400;
		nMotorEncoderTarget[motorLeft] = 1400;

		motor[motorRight] = -30;
		motor[motorLeft] = 30;

		while(nMotorRunState[motorRight] != runStateIdle || nMotorRunState[motorLeft] != runStateIdle)
		{
		}

		motor[motorRight] = 0;
		motor[motorLeft] = 0;
}


//////////////////////////////////////////////////////////////////////////////////////
//
//
// SwingTurnLeftRamp
//		Function used to turn towards ramp, when close to the perimeter wall
//
//////////////////////////////////////////////////////////////////////////////////////
void SwingTurnLeftRamp()
{
		nMotorEncoder[motorRight] = 0;
		nMotorEncoder[motorLeft] = 0;

		nMotorEncoderTarget[motorRight] = 2800;
		nMotorEncoderTarget[motorLeft] = 2800;

		motor[motorRight] = 30;
		motor[motorLeft] = -30;

		while(nMotorRunState[motorRight] != runStateIdle || nMotorRunState[motorLeft] != runStateIdle)
		{
		}

		motor[motorRight] = 0;
		motor[motorLeft] = 0;
}

//Drop Block NEW
void DropBlock()
{
	SwingTurnLeft();
	wait1Msec(10);
	Move(6, BACKWARD, 35);
	wait1Msec(10);
	motor[motorArm] = 30;
	wait10Msec(200);
	servo[servoClaw] = 110;
	servo[servoClaw] = 5;
	Move(2, FORWARD, 35);
}


/*
//Drop Block
void DropBlock()
{
	  //Move(4,BACKWARD, 20);
    //wait1Msec(10);
  //Swing Turn into the Basket, to position the robot for dropping the block
    SwingTurnLeft();
	  wait1Msec(10);
	//Move closer to the robot
	  Move(6,BACKWARD, 35);
	  wait1Msec(10);
	//Drop the block, hopefully, into the basket
	  //servo[servoClaw] = 110;
	  wait1Msec(1000);
	  //servo[servoClaw] = 5;
	  Move(2,FORWARD,35);
}
*/

//////////////////////////////////////////////////////////////////////////////////////
//
// IR Functions
//
//////////////////////////////////////////////////////////////////////////////////////
int  MoveUntilIR()
{
	//1. Reset the encoders
	nMotorEncoder[motorRight] = 0;
	nMotorEncoder[motorLeft] = 0;

	//2. Start the motors
	motor[motorRight] = 35;
	motor[motorLeft] = 35;

	//3. Set the variables to track the numbe of revolutions, so robot knows its position on the field
	int currentTicks = 0;
	string sTemp;

	// 4. Detect the IR beam
	// Read direction from the IR in a while loop
	// While loop exits, if either 5 is detected or if robot is past the 4th basket

	int direction = HTIRS2readACDir(IRSensor);
	while(  direction != 5  )  {
		// read the direction
		direction = HTIRS2readACDir(IRSensor);

		// read the number of ticks - that is how far the robot has moved since it started
		currentTicks = nMotorEncoder[motorRight];

		// check to see if we are past the 4th basket
		if (currentTicks >= BASKET_ZONE4_MAX )
		{
	  	//IR Seeker did not detect the IR beam, we are way past the 4th basket,
	    //need to stop moving
	    break;
		}
		sprintf(sTemp, "%d", currentTicks);
		nxtDisplayString(2, sTemp);
	}

	//5. Stop moving
	motor[motorRight] = 0;
	motor[motorLeft] = 0;

	//6. Return Ticks Moved
	return currentTicks;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
//
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving.
//
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void initializeRobot()
{

  // Place code here to initialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

	//IR Mode set
  tHTIRS2DSPMode _mode = DSP_1200;
	HTIRS2setDSPMode(IRSensor, _mode);

	//block drop servo motor position
	//servo[servoClaw] = 5;
	wait10Msec(10);
	return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation.
//
// Sequence of Operations:
//
// 1. Detect the IR beam
// 2. Turn and Drop the block
// 3. Find the Blue or Red Line
// 4. Climb the Ramp
//
// At the end of the autonomous period, the FMS will autonmatically abort execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
  initializeRobot();

  //waitForStart(); // Wait for the beginning of autonomous phase.

	///////////////////////////////////////////////////////
  //
  // Start of JDroids Autonomous Code
  // 1. Detect IR
  // 2. DropBlock
  // 3. SwingTurnLeft
  // 4. SwingTurnRight
  // 5. Backup
  // 6. SwingTurnLeftRamp
	// 7. MoveUntilBlueorRed
  // 8. TurnLeft
  // 9. MoveForward into Ramp
  //
  ///////////////////////////////////////////////////////

  //Coast the motors
 	bFloatDuringInactiveMotorPWM = true;

 	///////////////////////////////////////////////////////
 	//
 	// Detect the IR beam, we get out when 5 is detected
 	// returns the number of ticks moved
 	//
 	///////////////////////////////////////////////////////
 	int currentTicks = MoveUntilIR();
  wait10Msec(30);

  ///////////////////////////////////////////////////////
  //
  //Yay! We detected the beam!
  //Its about time we drop the block in the basket
  //
  ///////////////////////////////////////////////////////
  DropBlock();

  ///////////////////////////////////////////////////////
  //
  //okay, Now what?! Turn back to get back to ramp
  //
  ///////////////////////////////////////////////////////
  SwingTurnRight();


  ///////////////////////////////////////////////////////
  //
  // Logic below determines how much backward robot needs
  // based on which basket the block was dropped
  //
  ///////////////////////////////////////////////////////

  nMotorEncoder[motorLeft] = 0;
  nMotorEncoder[motorRight]= 0;
  nMotorEncoderTarget[motorLeft] =  (currentTicks * -1) + 1000;
  nMotorEncoderTarget[motorRight] =  (currentTicks * -1) + 1000;

  motor[motorLeft] = -40;
  motor[motorRight] = -40;
  while ( nMotorRunState[motorLeft] != runStateIdle || nMotorRunState[motorRight] != runStateIdle)
  {
  }
  motor[motorLeft] = 0;
  motor[motorRight] = 0;
  wait10Msec(20);

  ///////////////////////////////////////////////////////
  //
	// Final Step, We are almost there, Climb the ramp
  //
  ///////////////////////////////////////////////////////

	//turnleft towards the ramp
	SwingTurnLeftRamp();
	wait10Msec(20);

	//Find the white line
	MoveUntilBlueOrRed();

	Move(2,BACKWARD,60);
	wait10Msec(20);

	//postion towards the ramp
	TurnLeft();
	wait10Msec(30);

	//brakes so that the robot does not slide down the ramp
	bFloatDuringInactiveMotorPWM = false;

	//climb the ramp
	Move(23,FORWARD,60);

	///////////////////////////////////////////////////////
  //
	// We are done
  //
  ///////////////////////////////////////////////////////

  while (true)
	{

	}

}
