#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     colorSensor,    sensorI2CHiTechnicColor)
#pragma config(Sensor, S3,     IRSensor,       sensorI2CCustom)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     motorLeft,     tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorRight,    tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorArm,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorFlag,     tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)

/*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*/


///////////////////////////////////////////////////////////////////////////////////
//
//	MoveS
// 			This function moves the robot either Backwards or Forwards
//			based on the input parameters
//	Input Paramters:
//			distance: distance to move in inches
//			direction: should be either FORWARD(1) or BACKWARD (2)
//		  power: the speed with which the motor should move
//	Logic:
//			expects encoders to be attached to both drive motors
//		  reset the encoder, find the ticks based on wheel diameter
//			move the distance and stop when motor becomes idle
//
//////////////////////////////////////////////////////////////////////////////////////
void Move(int distance, int direction, int power)
{
	  //1. determine the number of ticks based on diameter and distance to travel
		int numberOfTicks = (ONE_REVOLUTION/(PI * WHEEL_DIAMETER)) * distance;

		//2. rest the encoder
		nMotorEncoder[motorRight] = 0;
		nMotorEncoder[motorLeft] = 0;

		//3. set the target
		nMotorEncoderTarget[motorRight] = numberOfTicks;
		nMotorEncoderTarget[motorLeft] = numberOfTicks;

		//4. set the power based on direction forward or backward
		if(direction == FORWARD){
			motor[motorRight] = power * -1;
			motor[motorLeft] = power * -1 ;
		}
		else{
			motor[motorRight] = power;
			motor[motorLeft] = power;
		}

		//5. check motor state to to keep running, if idle breaks out of while loop
		while(nMotorRunState[motorRight] != runStateIdle) {
			/* do nothing, the robot will keep moving,
			   since the power to motors is not cut off */
		}

		//6. we are done moving the required distance, stop the motors
		motor[motorRight] = 0;
		motor[motorLeft] = 0;

}

//////////////////////////////////////////////////////////////////////////////////////
//
// MoveUntilBlue
//	 Color Sensor connected on port 2
//////////////////////////////////////////////////////////////////////////////////////
void MoveUntilBlueOrRed()
{
	nMotorEncoder[motorRight] = 0;
	nMotorEncoder[motorLeft] = 0;
	motor[motorRight] = 35;
	motor[motorLeft] = 35;

	while( ( (SensorValue[S2] != BLUECOLOR) && (SensorValue[S2] != REDCOLOR) ) || ( (nMotorEncoder[motorRight] == 3500) && (nMotorEncoder[motorLeft] == 3500) ) )
	{
		//The motor continues running at -35 speed until the sensor does not detect EITHER red and blue OR it goes far
	}

	motor[motorRight] = 0;
	motor[motorLeft] = 0;
}
